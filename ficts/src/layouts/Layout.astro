---
// src/layouts/Layout.astro
import "../styles/global.css"; // Import Tailwind v4 here once
import Navbar from "../components/Navbar.astro";
import Footer from "../components/Footer.astro";

interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" href="/favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />

    <meta name="generator" content={Astro.generator} />
    <title>FICT Solutions</title>
  </head>
  <body>
    <!-- <div id="spiral-bg" class="bg-dots-container"></div> -->
    <Navbar />
    <main>
      <div id="spiral-bg" class="bg-dots-container"></div>
      <slot />
    </main>
    <Footer />

    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
      }
    </style>

    <script>
      // Wait for DOM to load
      document.addEventListener("DOMContentLoaded", () => {
        const backgrounds = document.querySelectorAll(".spiral-bg");

        if (backgrounds.length === 0) return;

        let frame = 0;
        let angle = 0;

        function animate() {
          // 1. Update Physics
          frame += 0.02; // Speed of the wave undulation
          angle += 0.05; // Speed of the rotation

          // 2. Calculate Spiral / Wave Motion
          // A Lissajous curve modified to look like a breathing spiral
          const radius = 50 + 10 * Math.sin(frame);
          const x = radius * Math.cos(angle * 0.05); // Slow orbit X
          const y = radius * Math.sin(angle * 0.05); // Slow orbit Y
          const rotate = angle * 0.2; // Continuous slow rotation

          // 3. Apply to ALL background instances
          backgrounds.forEach((bg) => {
            // We cast to HTMLElement to access style
            const element = bg as HTMLElement;
            element.style.setProperty("--x", `${x}px`);
            element.style.setProperty("--y", `${y}px`);
            element.style.setProperty("--r", `${rotate}deg`);
          });

          requestAnimationFrame(animate);
        }

        animate();
      });

      const canvas = document.getElementById("dotCanvas") as HTMLCanvasElement;
      const ctx = canvas.getContext("2d");

      let particles = [];
      const mouse = { x: -100, y: -100, radius: 100 };

      // 1. Resize handling
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        init();
      }

      // 2. Particle Object
      class Particle {
        x: number;
        y: number;
        baseX: number;
        baseY: number;
        size: number;
        density: number;
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.baseX = x; // Origin point
          this.baseY = y;
          this.size = 1.5;
          this.density = Math.random() * 30 + 1; // "Weight" of the dot
        }

        draw() {
          ctx.fillStyle = "rgba(74, 85, 104, 0.7)"; // Your #4a5568 color
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
        }

        update() {
          let dx = mouse.x - this.x;
          let dy = mouse.y - this.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          // Calculate force based on mouse distance
          if (distance < mouse.radius) {
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            const force = (mouse.radius - distance) / mouse.radius;
            const directionX = forceDirectionX * force * this.density;
            const directionY = forceDirectionY * force * this.density;

            this.x -= directionX;
            this.y -= directionY;
          } else {
            // Return to original position
            if (this.x !== this.baseX) {
              let dx = this.x - this.baseX;
              this.x -= dx / 10;
            }
            if (this.y !== this.baseY) {
              let dy = this.y - this.baseY;
              this.y -= dy / 10;
            }
          }
        }
      }

      function init() {
        particles = [];
        const gap = 30; // Spacing between dots
        for (let y = 0; y < canvas.height; y += gap) {
          for (let x = 0; x < canvas.width; x += gap) {
            particles.push(new Particle(x, y));
          }
        }
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < particles.length; i++) {
          particles[i].update();
          particles[i].draw();
        }
        requestAnimationFrame(animate);
      }

      // Listeners
      window.addEventListener("mousemove", (e) => {
        mouse.x = e.x;
        mouse.y = e.y;
      });

      window.addEventListener("resize", resize);

      resize();
      animate();
    </script>
  </body>
</html>
